

------------------------------------------------------------------------------------------------------------------------------------------

        1.内存泄露：
                    一般人们常说的内存泄露是指堆内存泄露。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定）
                
                使用完后必须显示释放的内存。应用程序一般使用malloc/realloc/new等函数从堆中分配到一块内存，使用完后，程序必须负责相
                
                应的调用free/delete释放该内存块，否则，在程序关掉之前（程序退出之后，操作系统会回收空间），这块内存就不能被再次使用
                
                我们就说这块内存泄露了。
                
        
       
       
       
        2.内存分配的“堆”和“栈”：
                    
                栈：就是那些由编译器在需要时分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量和函数参数等。
                    
                堆：就是那些由new/malloc/realloc分配的内存块，它们的释放编译器不去管，由应用程序去控制，每个new对应一个delete，
                    
                    如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
                        
                        
            2.1 堆和栈的主要区别：
                    
                    （1）管理方式和碎片问题
                        
                        对于栈，是由编译器自动管理的；对于堆，是由程序员来控制的，容易产生内存碎片。因为对于堆来讲，频繁的new、
                        
                        delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。而栈是后进先出的结构，不可能存在
                        
                        一个非栈顶内存块从栈中弹出，所以不会造成碎片。
                        
                    （2）分配效率
                    
                        栈是系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令
                        
                        执行，这就决定了栈的效率比较高。堆则是C/C++提供的，它的机制相对复杂，例如为了分配一块内存会按照一定的算
                        
                        法（内存分配算法）在堆中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是内存碎片太多），就有可能
                        
                        调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率要比
                        
                        栈低很多。
                        
                    （3）增长方式不同
                    
                        栈内存由一个指针esp来开辟和回收，栈内存是从高地址向低地址增长的，增长时，栈指针向低地址方向移动，指针的
                        
                        地址值也就相应的减小；回收时，栈指针向高地址方向移动，地址值也就增加。所以栈内存的开辟和回收都只是指针的
                        
                        加减。
                        
                        对于堆来讲，增长方向是向上的，也就是向着高地址方向移动；回收时，指针向低地址方向移动，地址值也就减小。
                        
                    （4）空间大小不同
                    
                        一般来讲，在32位的系统下，堆内存的空间可以达到4GB，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来
                        
                        讲，一般都是有一定空间大小的。无论是堆还是栈，都要防止越界的情况发生，因为越界的结果要么是程序崩溃，要么
                        
                        是摧毁程序的堆、栈结构，产生意想不到的结果。
        
        
        
               
                
       
        3.new/delete和malloc/free的区别：
        
                    1.malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
                    
                    2.对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象
                      
                      在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造
                      
                      函数和析构函数的任务强加于malloc/free；因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个
                      
                      能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

                    3.C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。

                    4.new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。 
                    
                    5.malloc分配失败时返回NULL；而new失败时抛出异常。
                    
                    6.malloc需要显示的指定分配内存的大小，而new则会自己计算将要开辟的内存大小。
                    
                    7.对于数组的处理，delete时必须使用 delete[] ；而malloc则不用。 
                    
                    8.operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。
                    
                        简单实现：
                                    void * operator new (size_t size)
                                    {
                                        if(void *p = malloc(size)
                                            return p;
                                        else
                                            throw bad_alloc();
                                    }
                        
                                    void operator delete(void *p) noexcept
                                    {
                                        free(p);
                                    }
                    
                    
                    9.malloc/free不允许被重载，而new/delete可以被重载。
                    
                    10.使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。
                    
                       realloc先判断当前的指针所指内存后边是否有足够的连续空间，如果有，在之前开辟内存块的尾部追加需要的大小并
                       
                       且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，
                       
                       然后释放之前的内存空间。但是new没有办法直接来扩充已开辟内存的大小。



------------------------------------------------------------------------------------------------------------------------------------------


